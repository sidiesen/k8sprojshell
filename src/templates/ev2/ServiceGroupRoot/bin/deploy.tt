# This script is used by Ev2 to deploy the helm charts.
# This is mostly done by the VSTS Release Pipeline, but you can also deploy locally with these steps:
# 1) Get the build number of the service you want to deploy. (e.g.: "1.0.01006.5")
# 2) Replace all instances of "!BUILDVERSION!" and "!CDPXBUILDVERSION!" in the entire solution with the buildnumber
#    EXCEPT for any occurrences in build.ps1.
#    You can also ignore any files in the \out\ folder, since they will be regenerated on build.
#    (or you can use the alternate method I shared via email)
# 3) Open Powershell and run .\deployment\ev2\InstallEv2.ps1 from the repo root.
#    This will ensure the Ev2 cmdlets are installed on your machine and loaded in the current Powershell session.
#    Sometimes when Ev2 changes their scripts this step might fail, in that case use the instructions here to install the cmdlets and try again:
#    https://microsoft.sharepoint.com/teams/WAG/EngSys/deploy/_layouts/OneNote.aspx?id=%2Fteams%2FWAG%2FEngSys%2Fdeploy%2FSiteAssets%2FExpress%20v2%20Notebook&wd=target%28Ev2%20Documentation.one%7CD41B1200-A6DE-4B4D-A019-8318B6F3A084%2FREQUIRED%3A%20Obtain%20the%20latest%20Ev2%20powershell%20cmdlets.%7C08603B0E-E03B-437E-A5B5-424A24823F55%2F%29onenote:https://microsoft.sharepoint.com/teams/WAG/EngSys/deploy/SiteAssets/Express%20v2%20Notebook/Ev2%20Documentation.one#REQUIRED%20Obtain%20the%20latest%20Ev2%20powershell%20cmdlets.&section-id={D41B1200-A6DE-4B4D-A019-8318B6F3A084}&page-id={08603B0E-E03B-437E-A5B5-424A24823F55}&end
# 4) Do a Release build of the project to regenerate the templated files.
# 5) Get JIT access (Portal access)!
# 6) Run the following commands to start the deployment, when asked for login credentials, login with your AME account with JIT access:
#       $ServiceGroupRoot = "<path_to_repo_root>\out\Release\ServiceGroupRoot\"
#       New-AzureServiceRollout -ServiceGroupRoot $ServiceGroupRoot -RolloutSpec <path_to_your_service_RolloutSpec_from_ServiceGroupRoot> -RolloutInfra <Prod/Test/NatCloud> -Verbose
#
#       e.g.: New-AzureServiceRollout -ServiceGroupRoot $ServiceGroupRoot -RolloutSpec EastUS\ClusterConfigRP\RolloutSpec.json -RolloutInfra Prod -Verbose
# 7) The cmdlet output will give you a link to an Ev2 dashboard, use that to monitor the deployment status.

[CmdletBinding()]
    param(
        [Switch]$All
    )

function Write-Object()
{
    [CmdletBinding()]
    param(
        $object
    )

    $object | ForEach-Object {Write-Host $_}
}

function DeployAll()
{
    Write-Host "Starting deploying image pull secrets to Cluster"

    $secretNamespaces = ($env:ImagePullSecretNamespaces).Split(";")
    $originalSecret = (& kubectl get secret acrregistrykey --namespace=default -o jsonpath="{.data.*}")

    $secretTemplate = @"
apiVersion: v1
kind: Secret
type: kubernetes.io/dockerconfigjson
data:
    .dockerconfigjson: $originalSecret
metadata:
    name: acrregistrykey
"@

    for ($i = 0; $i -lt $secretNamespaces.Count; $i++)
    {
        $secret = (& kubectl get secret acrregistrykey --namespace $secretNamespaces[$i] -o json | ConvertFrom-Json)
        if (!$secret)
        {
            Write-Host "Deploying image pull secret to namespace $($secretNamespaces[$i])"
            $secretTemplate | & kubectl apply --namespace=$($secretNamespaces[$i]) -f -
        }
    }

    Write-Host "Starting deployment of the full AKS cluster"

    $components = ($env:ComponentNames).Split(";")
    $chartPaths = ($env:ChartPaths).Split(";")
    $values = $env:ValuesFileName

    Write-Host "Deploying $($components.Count) components: $($env:ComponentNames)"

    if ($components.Count -ne $chartPaths.Count)
    {
        Write-Error "Components count $($components.Count) must be equal to ChartPaths count $($chartPaths.Count)"
        return 1
    }

    for ($i = 0; $i -lt $components.Count; $i++)
    {
        Write-Host "Deploying component $($i+1)/$($components.Count)"
        $env:ComponentName = $components[$i]
        $env:ChartPath = $chartPaths[$i]
        $env:ValuesFileName = $values
        
        $result = DeployComponent

        if ($result -ne 0)
        {
            Write-Error "Deployment failed for $($components[$i]). $($i)/$($components.Count) deployed successfully. Stopping."
            Write-Error "Return code: $result"
            return 1
        }
    }

    Write-Host "All components deployed successfully!"
    return 0
}

function CheckRolloutStatus()
{
    [CmdletBinding()]
    param(
        $DeploymentName,
        $DeploymentNamespace
    )

     switch ($env:ComponentName)
    {
        "keyvaultagent"
        {
            Write-Host "kubectl get pods --selector app=keyvaultagent --namespace $DeploymentNamespace"
            $pod = (& kubectl get pods --selector app=keyvaultagent --namespace $DeploymentNamespace -o json) | ConvertFrom-Json
            if (!$pod)
            {
                Write-Error "Unexpected error! Keyvaultagent pod does not exist!"
                exit 1
            }

            $status = $pod.items.status.containerStatuses[0].state.terminated.reason
            Write-Host ($pod.items.status.containerStatuses[0].state.terminated | Out-String)

            if ($status -eq "Completed")
            {
                return $true
            }
        }
        default
        {
            Write-Host "kubectl rollout status $DeploymentName --namespace $DeploymentNamespace --watch=false"
            $status = & kubectl rollout status $DeploymentName --namespace $DeploymentNamespace --watch=false
            Write-Object -object $status
            if ($status -like "*successfully rolled out*")
            {
                return $true
            }
        }
    }

    return $false
}

function DeployComponent()
{
    Write-Host "Start deployment for $env:ComponentName"

    # Only copy CDPX images for roles that start with solution prefix.
    if ($env:ComponentName -like "<#= solution.deploymentname #>*")
    {
        $buildversion = "!BUILDVERSION!"
        $cdpxbuildversion = "!CDPXBUILDVERSION!"
        if($buildversion -like '!BUIL*SION!')
        {
            # when running locally the buildversion is not substituted, as opposed to charts created in the CDPX pipeline
            $buildversion = "latest"
        }
        if($cdpxbuildversion -like '!CDPXBUIL*SION!')
        {
            # when running locally the buildversion is not substituted, as opposed to charts created in the CDPX pipeline
            $cdpxbuildversion = "latest"
        }
        $output = & az acr repository show --name $env:DeploymentAcrName --image "$($env:ComponentName):$($buildversion)"
        if (!$?) 
        {
            Write-Host "copy containers from CDPX ACR to our ACR"
            Write-Host "az acr import --name $env:DeploymentAcrName --source $env:SourceACR$($env:ComponentName):$($cdpxbuildversion) --image $($env:ComponentName):$($buildversion)"
            $output = & az acr import --name $env:DeploymentAcrName --source $env:SourceACR$($env:ComponentName):$($cdpxbuildversion) --image "$($env:ComponentName):$($buildversion)" --username $env:ACR_SPN_AppId --password $env:ACR_SPN_Key
            if (!$?)
            {
                Write-Error "Encountered an error while importing container image from CDPX"
                return 1
            }
            Write-Object -object $output
        }
        else
        {
            Write-Host "Image $env:ComponentName:$($buildversion) already exists. Skipping import."
            Write-Object -object $output
        }
    }  
    elseif ($env:ComponentName -eq "keyvaultagent")
    {
        Write-Host "copy KeyVault agent from Geneva ACR to our ACR"
        Write-Host "az acr import --force --name $env:DeploymentAcrName --source $($env:SourceACR)cckeyvaultagent:latest --image cckeyvaultagent:latest"
        $output = & az acr import --force --name "$env:DeploymentAcrName" --source "$($env:SourceACR)cckeyvaultagent:latest" --image "cckeyvaultagent:latest" --username $env:ACR_SPN_AppId --password $env:ACR_SPN_Key
        if (!$?)
        {
            Write-Error "Encountered an error while importing Keyvault container image from Geneva"
            return 1
        }
        Write-Object -object $output
    }  
    elseif ($env:ComponentName -eq "genevaservices")
    {
        Write-Host "az acr repository show --name $env:DeploymentAcrName --image genevamdsd:$env:GenevaMdsdVersion"
        $output = & az acr repository show --name $env:DeploymentAcrName --image genevamdsd:$env:GenevaMdsdVersion
        if (!$?) 
        {
            Write-Host "copy MDSD from Geneva ACR to our ACR"
            Write-Host "az acr import --name $env:DeploymentAcrName --source $($env:GenevaACR)genevamdsd:$env:GenevaMdsdVersion --image genevamdsd:$env:GenevaMdsdVersion"
            $output = & az acr import --name $env:DeploymentAcrName --source "$($env:GenevaACR)genevamdsd:$env:GenevaMdsdVersion" --username $env:ACR_SPN_AppId --password $env:ACR_SPN_Key
            if (!$?)
            {
                Write-Error "Encountered an error while importing Mdsd container image from Geneva"
                return 1
            }
            Write-Object -object $output
        }
        else
        {
            Write-Host "Image genevamdsd:$env:GenevaMdsdVersion already exists. Skipping import."
            Write-Object -object $output
        }

        Write-Host "& az acr repository show --name $env:DeploymentAcrName --image genevafluentd_td-agent:$env:GenevaFluentdVersion"
        $output = & az acr repository show --name $env:DeploymentAcrName --image genevafluentd_td-agent:$env:GenevaFluentdVersion
        if (!$?) 
        {
            Write-Host "copy FluentD from Geneva ACR to our ACR"
            Write-Host "az acr import --name $env:DeploymentAcrName --source $($env:GenevaACR)genevafluentd_td-agent:$($env:GenevaFluentdVersion) --image genevafluentd_td-agent:$($env:GenevaFluentdVersion)"
            $output = & az acr import --name $env:DeploymentAcrName --source "$($env:GenevaACR)genevafluentd_td-agent:$($env:GenevaFluentdVersion)" --username $env:ACR_SPN_AppId --password $env:ACR_SPN_Key
            if (!$?)
            {
                Write-Error "Encountered an error while importing FluentD container image from Geneva"
                return 1
            }
            Write-Object -object $output
        }
        else
        {
            Write-Host "Image genevafluentd_td-agent:$env:GenevaFluentdVersion already exists. Skipping import."
            Write-Object -object $output
        }

        Write-Host "az acr repository show --name $env:DeploymentAcrName --image genevamdm:$env:GenevaMdmVersion"
        $output = & az acr repository show --name $env:DeploymentAcrName --image genevamdm:$env:GenevaMdmVersion
        if (!$?) 
        {
            Write-Host "copy MDM from Geneva ACR to our ACR"
            Write-Host "az acr import --name $env:DeploymentAcrName --source $($env:GenevaACR)genevamdm:$($env:GenevaMdmVersion) --image genevamdm:$($env:GenevaMdmVersion)"
            $output = & az acr import --name $env:DeploymentAcrName --source "$($env:GenevaACR)genevamdm:$($env:GenevaMdmVersion)" --username $env:ACR_SPN_AppId --password $env:ACR_SPN_Key
            if (!$?)
            {
                Write-Error "Encountered an error while importing MDM container image from Geneva"
                return 1
            }
            Write-Object -object $output
        }
        else
        {
            Write-Host "Image genevamdm:$env:GenevaMdmVersion already exists. Skipping import."
            Write-Object -object $output
        }

        Write-Host "az acr repository show --name $env:DeploymentAcrName --image genevasecpackinstall:$env:GenevaSecpackVersion"
        $output = & az acr repository show --name $env:DeploymentAcrName --image genevasecpackinstall:$env:GenevaSecpackVersion
        if (!$?) 
        {
            Write-Host "copy AzSecPack from Geneva ACR to our ACR"
            Write-Host "az acr import --name $env:DeploymentAcrName --source $($env:GenevaACR)genevasecpackinstall:$($env:GenevaSecpackVersion) --image genevasecpackinstall:$($env:GenevaSecpackVersion)"
            $output = & az acr import --name $env:DeploymentAcrName --source "$($env:GenevaACR)genevasecpackinstall:$($env:GenevaSecpackVersion)" --username $env:ACR_SPN_AppId --password $env:ACR_SPN_Key
            if (!$?)
            {
                Write-Error "Encountered an error while importing AzSecPack container image from Geneva"
                return 1
            }
            Write-Object -object $output
        }
        else
        {
            Write-Host "Image genevasecpackinstall:$env:GenevaSecpackVersion already exists. Skipping import."
            Write-Object -object $output
        }
    }

    Write-Host "Helm List deployments"
    Write-Object -object (& helm ls)

    if ($env:ComponentName -eq "keyvaultagent") 
    {
        # If there's an existing keyvaultagent job, delete it before trying to create a new one.
        # Can't "upgrade" Jobs
        $keyvaultagentdeployment = & helm ls $env:ComponentName
        if ($keyvaultagentdeployment)
        {
            Write-Host "Existing KeyVaultAgent found, deleting before reinstall since upgrades are not supported."
            Write-Object -object (& helm delete $env:ComponentName --purge)
        }
    }

    if ($env:ComponentName -eq "aadpodidentity")
    {
        $aadpoddeployment = & helm ls $env:ComponentName
        if ($aadpoddeployment) 
        {
            # Upgrade the azure-aad-identity infra
            Write-Object -object (& kubectl apply -f https://raw.githubusercontent.com/Azure/aad-pod-identity/master/deploy/infra/deployment-rbac.yaml)
        }
        else 
        {
            # Deploy the azure-aad-identity infra
            Write-Object -object (& kubectl create -f https://raw.githubusercontent.com/Azure/aad-pod-identity/master/deploy/infra/deployment-rbac.yaml)
        }
    }

    switch ($env:ComponentName)
    {
        "genevaservices"
        {
            Write-Host "Helm upgrade $env:ComponentName --install --namespace $env:GenevaDeploymentNamespace -f ./ev2deploy/charts/$env:ChartPath/values.yaml -f ./ev2deploy/charts/$env:ChartPath/$env:ValuesFileName --set-file fluentd.conf=./ev2deploy/charts/$env:ChartPath/fluentd.conf --recreate-pods ./ev2deploy/charts/$env:ChartPath"
            $output = & helm upgrade $env:ComponentName --install --namespace $env:GenevaDeploymentNamespace -f "./ev2deploy/charts/$env:ChartPath/values.yaml" -f "./ev2deploy/charts/$env:ChartPath/$env:ValuesFileName" --set-file fluentd.conf="./ev2deploy/charts/$env:ChartPath/fluentd.conf" --recreate-pods "./ev2deploy/charts/$env:ChartPath"
        }
        "nginx-ingress"
        {
            Write-Host "Download stable/nginx-ingress"
            # NOTE: helm init is required for public charts, everything else we have is local charts.
            # consider moving this out if this changes.
            Write-Object -object (& helm init --client-only)
            Write-Host "helm upgrade $env:ComponentName --install --namespace $env:NginXDeploymentNamespace -f ./ev2deploy/charts/$env:ChartPath/$env:ValuesFileName stable/nginx-ingress"
            $output = & helm upgrade $env:ComponentName --install --namespace $env:NginXDeploymentNamespace -f "./ev2deploy/charts/$env:ChartPath/$env:ValuesFileName" stable/nginx-ingress
        }
        default
        {
            Write-Host "Helm upgrade $env:ComponentName --install --namespace $env:DeploymentNamespace -f ./ev2deploy/charts/$env:ChartPath/$env:ValuesFileName ./ev2deploy/charts/$env:ChartPath"
            $output = & helm upgrade $env:ComponentName --install --namespace $env:DeploymentNamespace -f "./ev2deploy/charts/$env:ChartPath/$env:ValuesFileName" "./ev2deploy/charts/$env:ChartPath"
        }
    }

    if (!$?)
    {
        Write-Error "Encountered error while trying to run helm upgrade"
        return 1
    }

    Write-Object -object $output

    # wait for all containers to hit ready state and timeout
    # we will only check daemonset, deployment or keyvaultagent. 
    $components = Get-Content -Path "./ev2deploy/charts/serviceInfo.json" -Raw | ConvertFrom-Json
    $deployment = $components.services | Where-Object {$_.service -eq $env:ComponentName}
    if (! $deployment)
    {
        Write-Warning "$env:ComponentName not listed in ./ev2deploy/charts/serviceInfo.json, skipping rollout verification"
        return 0
    }
    $deploymentName = "$($deployment.kind)/$($deployment.name)"
    $deploymentNamespace = "$($deployment.namespace)"

    $now = Get-Date
    $endTime = $now.AddMinutes(30)
    $deploymentReady = $false
    while ($now -lt $endTime)
    {
        if (CheckRolloutStatus -DeploymentName $deploymentName -DeploymentNamespace $deploymentNamespace)
        {
            $deploymentReady = $true
            break
        }
        Start-Sleep -Seconds 10
        $now = Get-Date
    }

    if (! $deploymentReady)
    {
        Write-Error "Deployment did not enter ready state within the specified timeout of 30 minutes!! Rolling back to previous revision!"

        Write-Object -object (& helm rollback $env:ComponentName 0)

        return 1
    }

    Write-Host "End deployment for $env:ComponentName"
    return 0
}

# Start Deploy.ps1

# Workaround for Canary where ev2 container cannot be deployed in eastus2euap
$ResourceGroupName = $env:AzureResourceGroupName
if ($env:AKSResourceGroupName)
{
    $ResourceGroupName = $env:AKSResourceGroupName
}
Write-Host "Using AKSResourceGroupName $ResourceGroupName"

#Write-Host "login with Service Principal to access ACR"
& az login --service-principal --username $env:SPN_AppId --password $env:SPN_Key --tenant $env:TenantId
if (!$?)
{
    Write-Error "Encountered an error while logging in with Service Principal"
    exit 1
}

& az account set --subscription $env:SubscriptionId
if (!$?)
{
    Write-Error "Encountered an error while switching to subscription $env:SubscriptionId"
    exit 1
}

Write-Host "Import kubernetes config"
& az aks get-credentials --name $env:AKSClusterName --resource-group $ResourceGroupName --admin
if (!$?)
{
    Write-Error "Encountered an error while getting AKS credentials"
    exit 1
}

# Look for tiller and if not installed, install it
$output = & kubectl get deployment/tiller-deploy --namespace kube-system
if (! $output)
{
    Write-Host "Initializing Tiller and Helm..."
    & kubectl create -f tiller-rbac-config.yaml
    & helm init --upgrade --wait --service-account tiller
}

$result = 0
if ($All)
{
    $result = DeployAll
}
else
{
    $result = DeployComponent
}

exit $result